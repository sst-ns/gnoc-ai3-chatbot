import React, { useState, useEffect, useMemo } from "react";
import ReactEcharts from "echarts-for-react";
import {
  connectWebSocket,
  listenForFetch,
  sendDeleteRequest,
} from "../../services/api";
import {
  Box,
  Typography,
  Collapse,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  IconButton,
  Dialog,
  Menu,
  MenuItem,
  Checkbox,
  TextField,
  Button,
} from "@mui/material";
import DeleteIcon from '@mui/icons-material/Delete';
import FilterListIcon from '@mui/icons-material/FilterList';
import ListItemText from '@mui/material/ListItemText';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowRightIcon from '@mui/icons-material/KeyboardArrowRight';
import AiLogo1 from "../../assets/logos/gnoc_ai3_sard_dimensions.svg";


import { useMsal } from "@azure/msal-react";
import { InteractionStatus } from "@azure/msal-browser";
import { loginRequest } from "../../../msalConfig";

/* ------------------------------------------------------------------ */
/*                              Component                             */
/* ------------------------------------------------------------------ */
const VulnerabilityOverview = () => {
  /* ────────  Chart + chat local state  ──────── */
  const [graphData, setGraphData]   = useState({});
  const [graph2Data, setGraph2Data] = useState({});
  const [graph3Data, setGraph3Data] = useState({});
  const [graph4Data, setGraph4Data] = useState({});
  
  /* ────────  MSAL / Auth state  ──────── */
  const { instance, accounts, inProgress } = useMsal();
  const [redirectDone, setRedirectDone]   = useState(false);
  const [accessGranted, setAccessGranted] = useState(null);
  const [accessToken, setAccessToken] = useState(null);

  /* ────────  UI and Data State  ──────── */
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [fetchedRows, setFetchedRows] = useState([]);
  const [expandedIncident, setExpandedIncident] = useState(null);
  const [openConfirmDialog, setOpenConfirmDialog] = useState(false);
  const [selectedIncident, setSelectedIncident] = useState(null);
  const [selectedYear, setSelectedYear] = useState("2023");
  const [selectedYearRCA, setSelectedYearRCA] = useState("2023");
  const [selectedYearAvgTime, setSelectedYearAvgTime] = useState("2023");
  const [columnFilters, setColumnFilters] = useState({
    Reported_Date_Time: [],
    Category: "",
    Source: "",
    Incident_Number: "",
    Region: ""
  });
  const [categoryAnchorEl, setCategoryAnchorEl] = useState(null);
  const [sourceAnchorEl, setSourceAnchorEl] = useState(null);
  const [incidentNumberAnchorEl, setIncidentNumberAnchorEl] = useState(null);
  const [dynamicCategories, setDynamicCategories] = useState([]);
  const [reportedDateAnchorEl, setReportedDateAnchorEl] = useState(null);
  const [dateFilterHierarchy, setDateFilterHierarchy] = useState({});
  const [expandedFilterItems, setExpandedFilterItems] = useState({});
  const [regionAnchorEl, setRegionAnchorEl] = useState(null);
  const [dynamicRegions, setDynamicRegions] = useState([]);


  // const requiredGroupId = "a413e120-33ad-4634-b863-9c38689b1462";
  const requiredGroupId = "04d6d1b8-fe98-42ba-aa33-dfa1e04eaa60";     // dev group 

  const incidentDetailKeys = {
    Impacted_Site_Service: "Impacted Site/Service",
    Permanent_Fix: "Permanent Fix",
    Problem_Record: "Problem Record",
    Incident_Description: "Incident Description",
    RCA_Analysis: "RCA Analysis",
    Root_Cause: "Root Cause",
    LocationImpacted: "Location Impacted",
    subcategory: "Subcategory",
    knowledgeArticle: "Knowledge Article",
    fileName: "Filename",
    Resolved_Date_Time: "Resolved Date Time",
    rcaLink: "RCA Link",
    ActionPlan: "Action Plan",
  };

  /* ------------------------------------------------------------------ */
  /*  Authentication and Data Fetching Effects                          */
  /* ------------------------------------------------------------------ */
  useEffect(() => {
    instance.handleRedirectPromise().catch((err) => console.error("Redirect error:", err)).finally(() => setRedirectDone(true));
  }, [instance]);

  useEffect(() => {
    if (!redirectDone || inProgress !== InteractionStatus.None || accounts.length > 0) return;
    instance.loginRedirect(loginRequest);
  }, [redirectDone, inProgress, accounts, instance]);

  useEffect(() => {
    if (!redirectDone || inProgress !== InteractionStatus.None || accounts.length === 0) return;
    const checkGroup = async () => {
      try {
        const tokenResp = await instance.acquireTokenSilent({ ...loginRequest, account: accounts[0] });
        if (!accessToken) setAccessToken(tokenResp.idToken || tokenResp.accessToken);
        const graphRes = await fetch("https://graph.microsoft.com/v1.0/me/memberOf?$select=id", { headers: { Authorization: `Bearer ${tokenResp.accessToken}` } });
        const data = await graphRes.json();
        setAccessGranted((data.value || []).some((g) => g.id === requiredGroupId));
      } catch (err) {
        console.error("Group check failed:", err);
        setAccessGranted(false);
      }
    };
    checkGroup();
  }, [redirectDone, inProgress, accounts, instance, accessToken]);

  useEffect(() => {
    if (!accessToken) return;
    connectWebSocket(accessToken);
    listenForFetch(
      (incidents) => setFetchedRows((prev) => {
        const uniqueMap = new Map(prev.map(item => [item.Incident_Number, item]));
        incidents.forEach((item) => uniqueMap.set(item.Incident_Number, item));
        return Array.from(uniqueMap.values());
      }),
      (g1) => setGraphData(g1 || {}),
      (g2) => setGraph2Data(g2 || {}),
      (g3) => setGraph3Data(g3 || {}),
      (g4) => setGraph4Data(g4 || {})
    );
  }, [accessToken]);

  useEffect(() => {
    const hierarchy = {};
    fetchedRows.forEach(row => {
      if (row.Reported_Date_Time) {
        const date = new Date(row.Reported_Date_Time);
        const year = date.getFullYear().toString();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.toISOString().split('T')[0];
        if (!hierarchy[year]) hierarchy[year] = {};
        if (!hierarchy[year][month]) hierarchy[year][month] = [];
        if (!hierarchy[year][month].includes(day)) hierarchy[year][month].push(day);
      }
    });
    setDateFilterHierarchy(hierarchy);
  }, [fetchedRows]);

  const months = useMemo(() => ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], []);
  
  /* ------------------------------------------------------------------ */
  /*                       Chart Options Generators                     */
  /* ------------------------------------------------------------------ */

  const getLineChartOptions = (selectedYear) => {
    const yearData = graphData[selectedYear] || {};
    const allCategoriesSet = new Set();
    months.forEach((month) => {
      const monthData = yearData[month] || {};
      Object.keys(monthData).forEach((cat) => allCategoriesSet.add(cat));
    });
    const allCategories = Array.from(allCategoriesSet);
    const series = allCategories.map((category) => {
      const seriesData = months.map((month) => (yearData[month] || {})[category] || 0);
      if (seriesData.some(v => v !== 0)) {
        return { 
          name: category, 
          type: "bar", 
          stack: selectedYear, 
          barGap: 0.2, 
          emphasis: { focus: "series" }, 
          data: seriesData,
          itemStyle: {
            shadowBlur: 8,
            shadowColor: 'rgba(0, 0, 0, 0.2)',
            shadowOffsetX: 2,
            shadowOffsetY: 2,
          }
        };
      }
      return null;
    }).filter(Boolean);

    return {
      title: { 
        text: `Monthly Incident Trend - ${selectedYear}`, 
        left: "center", 
        textStyle: { 
          fontSize: 16, 
          fontWeight: 600,
          color: '#2d1b69'
        } 
      },
      tooltip: { 
        trigger: 'item', 
        formatter: (params) => {
          if (params.value > 0) {
            return `${params.name}<br/><strong>${params.seriesName}</strong>: ${params.value}`;
          }
          return null;
        },
        backgroundColor: 'rgba(45, 27, 105, 0.9)',
        borderColor: '#7c4dff',
        textStyle: { color: '#fff' }
      },
      legend: { 
        show: true, 
        type: 'scroll', 
        bottom: 5,
        textStyle: { color: '#2d1b69' }
      },
      xAxis: { 
        type: "category", 
        data: months, 
        axisLabel: { 
          rotate: 45,
          color: '#2d1b69'
        },
        axisLine: { lineStyle: { color: '#7c4dff' } }
      },
      yAxis: { 
        type: "value", 
        name: "Incident Count",
        nameTextStyle: { color: '#2d1b69' },
        axisLabel: { color: '#2d1b69' },
        axisLine: { lineStyle: { color: '#7c4dff' } },
        splitLine: { lineStyle: { color: '#e8eaf6' } }
      },
      grid: { left: "6%", right: "4%", bottom: "15%", containLabel: true },
      series,
      color: ['#2d1b69', '#512da8', '#673ab7', '#7c4dff', '#9c27b0', '#ab47bc'],
    };
  };

 const getAvgTimeBarChartOptions = (year) => {

  // Step 1: Prepare data structures
  const regionSet = new Set();
  const monthRegionCounts = {};
  months.forEach(month => { monthRegionCounts[month] = {}; });
  // Use fetchedRows for the raw data

  (fetchedRows || []).forEach(row => {
    if (row.Reported_Date_Time && row.Region) {
      const date = new Date(row.Reported_Date_Time);
      const rowYear = date.getFullYear().toString();
      if (rowYear !== year) return;
      const month = months[date.getMonth()];
      const region = String(row.Region).trim();
      regionSet.add(region);
      if (!monthRegionCounts[month][region]) monthRegionCounts[month][region] = 0;
      monthRegionCounts[month][region]++;
    }
  });

  const allRegions = Array.from(regionSet).sort();
  // Step 2: Assemble series
  const series = allRegions.map(region => ({
    name: region,
    type: "bar",
    stack: year,
    emphasis: { focus: "series" },
    data: months.map(m => monthRegionCounts[m][region] || 0)
  }));

  // Step 3: Build options

  return {
    title: {
      text: `Incident Trend by Region - ${year}`,
      left: "center",
      textStyle: { fontSize: 16, fontWeight: 600, color: '#2d1b69' }
    },
    tooltip: { 
        trigger: 'item', 
        formatter: (params) => {
          if (params.value > 0) {
            return `${params.name}<br/><strong>${params.seriesName}</strong>: ${params.value}`;
          }
          return null;
        },
        backgroundColor: 'rgba(45, 27, 105, 0.9)',
        borderColor: '#7c4dff',
        textStyle: { color: '#fff' }
      },
    legend: { show: true, type: 'scroll', bottom: 5, textStyle: { color: '#2d1b69' } },
    xAxis: {
      type: "category",
      data: months,
      axisLabel: { rotate: 45, color: '#2d1b69' },
      axisLine: { lineStyle: { color: '#7c4dff' } }
    },
    yAxis: {
      type: "value",
      name: "Incident Count",
      nameTextStyle: { color: '#2d1b69' },
      axisLabel: { color: '#2d1b69' },
      axisLine: { lineStyle: { color: '#7c4dff' } },
      splitLine: { lineStyle: { color: '#e8eaf6' } }
    },
    grid: { left: "6%", right: "4%", bottom: "15%", containLabel: true },
    series,
    color: [
      '#2d1b69', '#512da8', '#673ab7', '#7c4dff', '#9c27b0', '#ab47bc',
      '#ce93d8', '#26a69a', '#ff7043', '#ec407a'
    ]
  };
};


  const getRcaBarChartOptions = (graph3Data) => {
    const years = ["2023", "2024", "2025"];
    const seriesData = years.map(year => Object.values(graph3Data?.[year] || {}).reduce((sum, count) => sum + (count || 0), 0));
    return {
      title: { 
        text: "RCA Count by Year", 
        left: "center", 
        textStyle: { 
          fontSize: 16, 
          fontWeight: 600,
          color: '#2d1b69'
        } 
      },
      tooltip: { 
        trigger: "axis", 
        axisPointer: { type: "shadow" }, 
        formatter: (params) => `${params[0].name}<br/>RCA Count: ${params[0].value}`,
        backgroundColor: 'rgba(45, 27, 105, 0.9)',
        borderColor: '#7c4dff',
        textStyle: { color: '#fff' }
      },
      xAxis: { 
        type: "category", 
        data: years, 
        axisLabel: { 
          fontSize: 12,
          color: '#2d1b69'
        },
        axisLine: { lineStyle: { color: '#7c4dff' } }
      },
      yAxis: { 
        type: "value", 
        name: "RCA Count", 
        min: 0,
        nameTextStyle: { color: '#2d1b69' },
        axisLabel: { color: '#2d1b69' },
        axisLine: { lineStyle: { color: '#7c4dff' } },
        splitLine: { lineStyle: { color: '#e8eaf6' } }
      },
      series: [{ 
        name: "RCA Count", 
        type: "bar", 
        data: seriesData, 
        barWidth: "40%", 
        emphasis: { focus: "series" },
        itemStyle: {
          borderRadius: [8, 8, 0, 0],
          color: {
            type: 'linear',
            x: 0, y: 0, x2: 0, y2: 1,
            colorStops: [
              { offset: 0, color: '#ab47bc' },
              { offset: 1, color: '#2d1b69' }
            ]
          },
          shadowBlur: 8,
          shadowColor: 'rgba(0, 0, 0, 0.2)',
          shadowOffsetX: 2,
          shadowOffsetY: 2,
        }
      }],
      grid: { left: "6%", right: "4%", bottom: "8%", containLabel: true },
    };
  };
  
  const getRcaPriorityPieChartOptions = (graph4Data, selectedYear) => {
    const yearData = graph4Data?.[selectedYear];
    if (!yearData) return {};
    const data = Object.entries(yearData).map(([priority, count]) => ({ name: priority, value: count }));
    return {
      title: { 
        text: `RCA Distribution by Priority - ${selectedYear}`, 
        left: "center",
        textStyle: { 
          color: '#2d1b69',
          fontSize: 16,
          fontWeight: 600
        }
      },
      tooltip: { 
        trigger: "item",
        backgroundColor: 'rgba(45, 27, 105, 0.9)',
        borderColor: '#7c4dff',
        textStyle: { color: '#fff' }
      },
      legend: {
        orient: "horizontal",
        bottom: 0,
        type: "scroll",
        textStyle: { color: '#2d1b69' }
      },
      series: [{ 
        name: "Priority", 
        type: "pie", 
        radius: "55%", 
        data, 
        emphasis: { 
          itemStyle: { 
            shadowBlur: 15, 
            shadowOffsetX: 0, 
            shadowColor: "rgba(45, 27, 105, 0.5)" 
          } 
        }, 
        label: { 
          formatter: "{b}: {c} ({d}%)",
          color: '#2d1b69'
        },
        itemStyle: {
          borderRadius: 8,
          borderColor: '#fff',
          borderWidth: 2
        }
      }],
      color: ['#2d1b69', '#512da8', '#7c4dff', '#ab47bc', '#9c27b0', '#ce93d8'],
    };
  };
  
 useEffect(() => {
  const regions = [];
  const seen = new Set();
  fetchedRows.forEach(row => {
    const reg = String(row.Region ?? "").trim();
    if (reg && !seen.has(reg.toLowerCase())) {
      seen.add(reg.toLowerCase());
      regions.push(reg);
    }
  });
  setDynamicRegions(regions.sort());
}, [fetchedRows]);


  /* ------------------------------------------------------------------ */
  /*                      Event Handlers & UI Logic                     */
  /* ------------------------------------------------------------------ */
  useEffect(() => { setDynamicCategories([...new Set(fetchedRows.map(row => row.Category).filter(Boolean))].sort()); }, [fetchedRows]);
  const handleChangePage = (event, newPage) => setPage(newPage);
  const handleChangeRowsPerPage = (event) => { setRowsPerPage(parseInt(event.target.value, 10)); setPage(0); };
  const handleToggle = (incidentNumber) => setExpandedIncident(prev => prev === incidentNumber ? null : incidentNumber);
  const handleDeleteClick = (incidentNumber) => { setSelectedIncident(incidentNumber); setOpenConfirmDialog(true); };
  const handleConfirmDelete = () => { sendDeleteRequest(selectedIncident); setOpenConfirmDialog(false); };
  const handleCancelDelete = () => { setSelectedIncident(null); setOpenConfirmDialog(false); };
  const handleFilterExpand = (key) => setExpandedFilterItems(prev => ({ ...prev, [key]: !prev[key] }));

  const handleDateSelect = (items, shouldSelect) => {
    const currentSelection = new Set(columnFilters.Reported_Date_Time);
    items.forEach(item => shouldSelect ? currentSelection.add(item) : currentSelection.delete(item));
    setColumnFilters(prev => ({ ...prev, Reported_Date_Time: Array.from(currentSelection) }));
  };

  const getSelectionState = (items) => {
    const selectedCount = items.filter(item => columnFilters.Reported_Date_Time.includes(item)).length;
    if (selectedCount === 0) return { checked: false, indeterminate: false };
    if (selectedCount === items.length) return { checked: true, indeterminate: false };
    return { checked: false, indeterminate: true };
  };

const filteredRows = useMemo(() => fetchedRows.filter((row) => {
  // Normalize and compare both sides
  const regionCell = String(row.Region ?? "").trim().toLowerCase();
  const regionFilter = String(columnFilters.Region ?? "").trim().toLowerCase();
  const regionMatch = regionFilter === "" || regionCell === regionFilter;

  // ... your other matching logic remains the same
  // Don't forget to do similar for other text filters, if needed
  // e.g. category, source, etc.

  const rowDate = row.Reported_Date_Time ? new Date(row.Reported_Date_Time).toISOString().split("T")[0] : null;
  const categoryMatch = columnFilters.Category === "" || row.Category === columnFilters.Category;
  const dateMatch = columnFilters.Reported_Date_Time.length === 0 || (rowDate && columnFilters.Reported_Date_Time.includes(rowDate));
  const sourceMatch = columnFilters.Source === "" || row.Source === columnFilters.Source;
  const incidentNumberMatch = row.Incident_Number.toLowerCase().includes(columnFilters.Incident_Number.toLowerCase());
  return categoryMatch && dateMatch && sourceMatch && regionMatch && incidentNumberMatch;
}), [fetchedRows, columnFilters]);


  
  if (inProgress !== InteractionStatus.None) return <p>Loading…</p>;
  if (accessGranted === null) return <p>Verifying access…</p>;
  if (!accessGranted) {
    setTimeout(() => {
      window.location.href = "https://netservbot.ciostage.accenture.com/";
    }, 10000);
    return (
     <div
        style={{
          height: '80vh',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          flexDirection: 'column',
          background: '#EDE0F7'
        }}
      >
        <Typography variant="h4" gutterBottom style={{ color: '#2d1b69', fontWeight: 700 }}>
          Access Denied
        </Typography>
        <Typography variant="h5" gutterBottom>
          Sorry, you do not have permission to access this page.
        </Typography>
        <br></br>
        <Typography variant="body1" gutterBottom>
          You will be redirected to home after 2 seconds.
        </Typography>
        <Button
          onClick={() => window.location.href = "https://netservbot.ciostage.accenture.com/"}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            cursor: 'pointer',
            background: '#fff',
            color: '#2d1b69',
            border: '2px solid #2d1b69',
            borderRadius: 8,
            fontWeight: 600,
            boxShadow: '0 4px 15px rgba(57, 74, 140, 0.3)',
            transition: 'all 0.3s ease',
          }}
        >
          Return to Homepage
        </Button>
      </div>
    );
  }

  return (
    <div style={{ padding: 5, fontFamily: "Segoe UI, sans-serif", background: 'linear-gradient(135deg, #f5f3ff 0%, #ede7f6 100%)', minHeight: '100vh', overflowX: 'hidden' }}>
      <h2 style={{ color: '#2d1b69', marginBottom: '20px' }}>Incident Overview</h2>
      <div style={{ display: "flex", flexWrap: "wrap", gap: 20}}>
        {/* Graph 1 */}
        <div style={cardStyle}>
            <ReactEcharts key={selectedYear} option={getLineChartOptions(selectedYear)} style={{ height: 300 }} />
            <div style={{ textAlign: "center", marginTop: 10 }}>
              {["2023", "2024", "2025"].map((year) => (
                <button key={year} onClick={() => setSelectedYear(year)} style={{ ...buttonStyle, ...(selectedYear === year && activeButtonStyle) }}>{year}</button>
              ))}
            </div>
        </div>
        {/* Graph 2 */}
        <div style={cardStyle}>
            <ReactEcharts key={selectedYearAvgTime} option={getAvgTimeBarChartOptions(selectedYearAvgTime)} style={{ height: 300 }} />
            <div style={{ textAlign: "center", marginTop: 10 }}>
              {["2023", "2024", "2025"].map((year) => (
                <button key={year} onClick={() => setSelectedYearAvgTime(year)} style={{ ...buttonStyle, ...(selectedYearAvgTime === year && activeButtonStyle) }}>{year}</button>
              ))}
            </div>
        </div>
        {/* Graph 3 */}
        <div style={cardStyle}>
            <ReactEcharts option={getRcaBarChartOptions(graph3Data)} style={{ height: 300 }} />
        </div>
        {/* Graph 4 */}
        <div style={cardStyle}>
            <ReactEcharts option={getRcaPriorityPieChartOptions(graph4Data, selectedYearRCA)} style={{ height: 300 }} />
            <div style={{ textAlign: "center", marginTop: 10 }}>
              <span style={{ fontSize: "12px", marginRight: "10px", color: '#2d1b69' }}>Priority for:</span>
              {["2023", "2024", "2025"].map((year) => (
                <button key={year} onClick={() => setSelectedYearRCA(year)} style={{ ...smallButtonStyle, ...(selectedYearRCA === year && activeSmallButtonStyle) }}>{year}</button>
              ))}
            </div>
        </div>
      </div>

      {/* TABLE */}
      <Box>
        <Paper sx={{ mt: 3, borderRadius: 3, boxShadow: '0 8px 32px rgba(45, 27, 105, 0.15)', overflow: 'hidden' }}>
                    <TableContainer sx={{ overflowX: 'auto' }}>
            <Table>
              <TableHead>
                <TableRow sx={{ background: 'linear-gradient(135deg, #370467 0%, #370467 100%)', '& .MuiTableCell-root': { borderBottom: 'none' } }}>
                  <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      Incident Number
                      <IconButton size="small" onClick={(e) => setIncidentNumberAnchorEl(e.currentTarget)} sx={{ ml: 1, color: "white" }}><FilterListIcon fontSize="small" /></IconButton>
                    </Box>
                    <Menu anchorEl={incidentNumberAnchorEl} open={Boolean(incidentNumberAnchorEl)} onClose={() => setIncidentNumberAnchorEl(null)}>
                      <Box sx={{ p: 2 }}>
                        <TextField variant="outlined" size="small" placeholder="Search..." value={columnFilters.Incident_Number} onChange={(e) => setColumnFilters(prev => ({ ...prev, Incident_Number: e.target.value }))} onClick={(e) => e.stopPropagation()} />
                      </Box>
                    </Menu>
                  </TableCell>
                  <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      Reported Date
                      <IconButton size="small" onClick={(e) => setReportedDateAnchorEl(e.currentTarget)} sx={{ ml: 1, color: "white" }}><FilterListIcon fontSize="small" /></IconButton>
                    </Box>
                    <Menu anchorEl={reportedDateAnchorEl} open={Boolean(reportedDateAnchorEl)} onClose={() => setReportedDateAnchorEl(null)} PaperProps={{ style: { maxHeight: 400, width: '30ch' } }}>
                      <MenuItem onClick={() => handleDateSelect(Object.values(dateFilterHierarchy).flatMap(y => Object.values(y).flat()), false)}><ListItemText primary="Clear All" /></MenuItem>
                      {Object.entries(dateFilterHierarchy).sort((a, b) => b[0].localeCompare(a[0])).map(([year, months]) => {
                        const yearDates = Object.values(months).flat();
                        const { checked: yearChecked, indeterminate: yearIndeterminate } = getSelectionState(yearDates);
                        return (
                          <div key={year}>
                            <MenuItem>
                              <IconButton size="small" onClick={() => handleFilterExpand(year)}>{expandedFilterItems[year] ? <KeyboardArrowDownIcon /> : <KeyboardArrowRightIcon />}</IconButton>
                              <Checkbox checked={yearChecked} indeterminate={yearIndeterminate} onClick={() => handleDateSelect(yearDates, !yearChecked)} />
                              <ListItemText primary={year} />
                            </MenuItem>
                            <Collapse in={expandedFilterItems[year]} timeout="auto" unmountOnExit>
                              <Box sx={{ pl: 4 }}>
                                {Object.entries(months).sort((a, b) => a[0].localeCompare(b[0])).map(([month, days]) => {
                                  const monthDates = days;
                                  const { checked: monthChecked, indeterminate: monthIndeterminate } = getSelectionState(monthDates);
                                  const monthName = new Date(year, month - 1).toLocaleString('default', { month: 'long' });
                                  return (
                                    <div key={month}>
                                      <MenuItem>
                                        <IconButton size="small" onClick={() => handleFilterExpand(`${year}-${month}`)}>{expandedFilterItems[`${year}-${month}`] ? <KeyboardArrowDownIcon /> : <KeyboardArrowRightIcon />}</IconButton>
                                        <Checkbox checked={monthChecked} indeterminate={monthIndeterminate} onClick={() => handleDateSelect(monthDates, !monthChecked)} />
                                        <ListItemText primary={monthName} />
                                      </MenuItem>
                                      <Collapse in={expandedFilterItems[`${year}-${month}`]} timeout="auto" unmountOnExit>
                                        <Box sx={{ pl: 4 }}>
                                          {days.sort((a, b) => a.localeCompare(b)).map(day => {
                                            const { checked: dayChecked } = getSelectionState([day]);
                                            return (
                                              <MenuItem key={day} onClick={() => handleDateSelect([day], !dayChecked)}>
                                                <Checkbox checked={dayChecked} /><ListItemText primary={day} />
                                              </MenuItem>
                                            );
                                          })}
                                        </Box>
                                      </Collapse>
                                    </div>
                                  );
                                })}
                              </Box>
                            </Collapse>
                          </div>
                        );
                      })}
                    </Menu>
                  </TableCell>
                  <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>Problem Statement</TableCell>
                  <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>Time Taken to Resolve(in mins)</TableCell>
                  <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      Category<IconButton size="small" onClick={(e) => setCategoryAnchorEl(e.currentTarget)} sx={{ ml: 1, color: "white" }}><FilterListIcon fontSize="small" /></IconButton>
                    </Box>
                    <Menu anchorEl={categoryAnchorEl} open={Boolean(categoryAnchorEl)} onClose={() => setCategoryAnchorEl(null)}>
                      <MenuItem onClick={() => { setColumnFilters((prev) => ({ ...prev, Category: "" })); setCategoryAnchorEl(null); }} selected={columnFilters.Category === ""}><Checkbox checked={columnFilters.Category === ""} /><ListItemText primary="All" /></MenuItem>
                      {dynamicCategories.map((cat) => (
                        <MenuItem key={cat} selected={columnFilters.Category === cat} onClick={() => { setColumnFilters((prev) => ({ ...prev, Category: cat })); setCategoryAnchorEl(null); }}><Checkbox checked={columnFilters.Category === cat} /><ListItemText primary={cat} /></MenuItem>
                      ))}
                    </Menu>
                  </TableCell>
                  <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      Region
                      <IconButton size="small" onClick={(e) => setRegionAnchorEl(e.currentTarget)} sx={{ ml: 1, color: "white" }}><FilterListIcon fontSize="small" /></IconButton>
                    </Box>
                    <Menu
                      anchorEl={regionAnchorEl}
                      open={Boolean(regionAnchorEl)}
                      onClose={() => setRegionAnchorEl(null)}
                    >
                      <MenuItem
                        onClick={() => { setColumnFilters(prev => ({ ...prev, Region: "" })); setRegionAnchorEl(null); }}
                        selected={columnFilters.Region === ""}
                      >
                        <Checkbox checked={columnFilters.Region === ""} />
                        <ListItemText primary="All" />
                      </MenuItem>
                      {dynamicRegions.map((reg) => (
                        <MenuItem
                          key={reg}
                          selected={columnFilters.Region === reg}
                          onClick={() => { setColumnFilters(prev => ({ ...prev, Region: reg })); setRegionAnchorEl(null); }}
                        >
                          <Checkbox checked={columnFilters.Region === reg} />
                          <ListItemText primary={reg} />
                        </MenuItem>
                      ))}
                    </Menu>
                  </TableCell>
                  <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      Source<IconButton size="small" onClick={(e) => setSourceAnchorEl(e.currentTarget)} sx={{ ml: 1, color: "white" }}><FilterListIcon fontSize="small" /></IconButton>
                    </Box>
                    <Menu anchorEl={sourceAnchorEl} open={Boolean(sourceAnchorEl)} onClose={() => setSourceAnchorEl(null)}>
                      <MenuItem onClick={() => { setColumnFilters((prev) => ({ ...prev, Source: "" })); setSourceAnchorEl(null); }} selected={columnFilters.Source === ""}><Checkbox checked={columnFilters.Source === ""} /><ListItemText primary="All" /></MenuItem>
                      <MenuItem onClick={() => { setColumnFilters((prev) => ({ ...prev, Source: "MDB" })); setSourceAnchorEl(null); }} selected={columnFilters.Source === "MDB"}><Checkbox checked={columnFilters.Source === "MDB"} /><ListItemText primary="MDB" /></MenuItem>
                      <MenuItem onClick={() => { setColumnFilters((prev) => ({ ...prev, Source: "RCA" })); setSourceAnchorEl(null); }} selected={columnFilters.Source === "RCA"}><Checkbox checked={columnFilters.Source === "RCA"} /><ListItemText primary="RCA" /></MenuItem>
                    </Menu>
                  </TableCell>
                  <TableCell sx={{ color: "white" , whiteSpace: "nowrap"}}></TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {(filteredRows || []).slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage).map((row) => (
                  <React.Fragment key={row.Incident_Number}>
                    <TableRow hover sx={{ '&:hover': { backgroundColor: '#f3e5f5' } }}>
                      <TableCell><Typography sx={{ cursor: "pointer", color: "#2d1b69", textDecoration: "underline", fontWeight: 500 }} onClick={() => handleToggle(row.Incident_Number)}>{row.Incident_Number}</Typography></TableCell>
                      <TableCell sx={{ color: '#424242' }}>{new Date(row.Reported_Date_Time).toISOString().split("T")[0]}</TableCell>
                      <TableCell><Typography title={row.Problem_Statement} sx={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', maxWidth: 200, cursor: 'pointer', color: '#424242' }}>{row.Problem_Statement}</Typography></TableCell>
                      <TableCell sx={{ color: '#424242' }}>{row.Time_Taken_to_Resolve}</TableCell>
                      <TableCell sx={{ color: '#424242' }}>{row.Category}</TableCell>
                      <TableCell sx={{ color: '#424242' }}>{(Array.isArray(row.Region) ? row.Region.join(", ") : String(row.Region))}</TableCell>
                      <TableCell sx={{ color: '#424242' }}>{row.Source}</TableCell>
                      <TableCell><IconButton color="error" onClick={() => handleDeleteClick(row.Incident_Number)} sx={{ '&:hover': { backgroundColor: '#ffebee' } }}><DeleteIcon /></IconButton></TableCell>
                    </TableRow>
                    <Dialog open={openConfirmDialog} onClose={handleCancelDelete} BackdropProps={{ style: { backgroundColor: 'rgba(45, 27, 105, 0.3)', backdropFilter: 'blur(2px)' } }}>
                      <Box p={3} sx={{ background: 'linear-gradient(135deg, #f5f3ff 0%, #ede7f6 100%)' }}>
                        <Typography variant="h6" sx={{ color: '#2d1b69' }}>Are you sure you want to delete this record?</Typography>
                        <Box mt={2} display="flex" justifyContent="flex-end">
                          <button onClick={handleCancelDelete} style={{ ...dialogButtonStyle, marginRight: "10px" }}>No</button>
                          <button onClick={handleConfirmDelete} style={{ ...dialogButtonStyle, backgroundColor: "#d32f2f", color: "white" }}>Yes</button>
                        </Box>
                      </Box>
                    </Dialog>
                    {expandedIncident === row.Incident_Number && (
                      <TableRow>
                        <TableCell colSpan={8}>
                          <Collapse in={true} timeout="auto" unmountOnExit>
                            <Paper elevation={3} sx={{ p: 2, mt: 1, background: 'linear-gradient(135deg, #f8f5ff 0%, #f3e5f5 100%)', borderRadius: 2 }}>
                              <Typography variant="h6" gutterBottom sx={{ color: '#2d1b69' }}>Incident Details</Typography>
                              {Object.entries(incidentDetailKeys).map(([key, label]) => {
                                const value = row[key];
                                if (!value) return null;
                                if (key === "rcaLink") return (<Typography key={key} sx={{ color: '#424242' }}><strong style={{ color: '#2d1b69' }}>{label}:</strong> <a href={`https://${value}`} target="_blank" rel="noopener noreferrer" style={{ color: '#7c4dff' }}>{value}</a></Typography>);
                                if (key === "ActionPlan" && Array.isArray(value) && value.length > 0) {
                                  const headers = Object.keys(value[0]);
                                  return (
                                    <Box key={key} sx={{ mt: 2 }}>
                                      <Typography variant="subtitle1" gutterBottom sx={{ color: '#2d1b69' }}><strong>{label}</strong></Typography>
                                      <TableContainer component={Paper} sx={{ borderRadius: 2 }}><Table size="small">
                                        <TableHead><TableRow sx={{ backgroundColor: '#e8eaf6' }}>{headers.map(h => <TableCell key={h} sx={{ textTransform: 'capitalize', color: '#2d1b69', fontWeight: 600 }}>{h.replace(/_/g, ' ')}</TableCell>)}</TableRow></TableHead>
                                        <TableBody>{value.map((p, i) => <TableRow key={i}>{headers.map(h => <TableCell key={h} sx={{ color: '#424242' }}>{p[h]}</TableCell>)}</TableRow>)}</TableBody>
                                      </Table></TableContainer>
                                    </Box>
                                  );
                                }
                                if (key !== "ActionPlan") return (<Typography key={key} sx={{ color: '#424242' }}><strong style={{ color: '#2d1b69' }}>{label}:</strong> {value}</Typography>);
                                return null;
                              })}
                            </Paper>
                          </Collapse>
                        </TableCell>
                      </TableRow>
                    )}
                  </React.Fragment>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
          <TablePagination
            component="div"
            count={filteredRows.length}
            page={page}
            onPageChange={handleChangePage}
            rowsPerPage={rowsPerPage}
            onRowsPerPageChange={handleChangeRowsPerPage}
            rowsPerPageOptions={[1, 5, 10, 50]}
            sx={{
              backgroundColor: 'linear-gradient(135deg, #2d1b69 0%, #512da8 100%)',
              color: 'white',
              '& .MuiTablePagination-selectLabel': {
                color: 'white',
                fontWeight: 500
              },
              '& .MuiTablePagination-select': {
                color: 'white'
              },
              '& .MuiTablePagination-displayedRows': {
                color: 'white',
                fontWeight: 500
              },
              '& .MuiTablePagination-actions': {
                color: 'white'
              },
              '& .MuiSelect-icon': {
                color: 'white'
              },
              '& .MuiIconButton-root': {
                color: 'white',
                '&:hover': {
                  backgroundColor: 'rgba(255, 255, 255, 0.1)'
                },
                '&.Mui-disabled': {
                  color: 'rgba(255, 255, 255, 0.5)'
                }
              }
            }}
          />
        </Paper>
      </Box>
    </div>
  );
};

const cardStyle = {
  flex: "1 1 calc(50% - 10px)",
  boxSizing: "border-box",
  background: "linear-gradient(135deg, #ffffff 0%, #f8f5ff 100%)",
  borderRadius: 16,
  boxShadow: "0 8px 32px rgba(45, 27, 105, 0.15)",
  padding: 20,
  minWidth: "350px",
  border: "1px solid rgba(124, 77, 255, 0.1)",
};

const buttonStyle = {
  margin: "0 8px",
  padding: "8px 16px",
  borderRadius: "8px",
  border: "2px solid #e0e0e0",
  backgroundColor: "#fff",
  cursor: "pointer",
  fontWeight: 500,
  color: '#2d1b69',
  transition: 'all 0.3s ease',
};

const activeButtonStyle = {
  fontWeight: 600,
  border: "2px solid #2d1b69",
  backgroundColor: "#f3e5f5",
  color: '#2d1b69',
  transform: 'translateY(-2px)',
  boxShadow: '0 4px 12px rgba(45, 27, 105, 0.2)',
};

const smallButtonStyle = {
  margin: "0 4px",
  padding: "6px 12px",
  fontSize: "12px",
  borderRadius: "6px",
  border: "2px solid #e0e0e0",
  backgroundColor: "#fff",
  cursor: "pointer",
  fontWeight: 500,
  color: '#2d1b69',
  transition: 'all 0.3s ease',
};

const activeSmallButtonStyle = {
  fontWeight: 600,
  border: "2px solid #2d1b69",
  backgroundColor: "#f3e5f5",
  color: '#2d1b69',
  transform: 'translateY(-1px)',
  boxShadow: '0 2px 8px rgba(45, 27, 105, 0.2)',
};

const dialogButtonStyle = {
  padding: "8px 16px",
  borderRadius: "6px",
  border: "2px solid #2d1b69",
  backgroundColor: "#fff",
  color: "#2d1b69",
  cursor: "pointer",
  fontWeight: 500,
  transition: 'all 0.3s ease',
};

export default VulnerabilityOverview;