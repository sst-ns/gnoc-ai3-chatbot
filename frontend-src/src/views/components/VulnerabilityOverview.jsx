import React, { useState, useEffect, useMemo } from "react";
import ReactEcharts from "echarts-for-react";
import {
  connectWebSocket,
  listenForFetch,
  sendChatMessageToBackend,
  sendFetchRequest,
  sendDeleteRequest,
} from "../../services/api";
import {
  Box,
  Typography,
  Collapse,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  IconButton,
  Dialog,
  Menu,
  MenuItem,
  Checkbox,
  TextField,
} from "@mui/material";
import DeleteIcon from '@mui/icons-material/Delete';
import FilterListIcon from '@mui/icons-material/FilterList';
import ListItemText from '@mui/material/ListItemText';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowRightIcon from '@mui/icons-material/KeyboardArrowRight';


import { useMsal } from "@azure/msal-react";
import { InteractionStatus } from "@azure/msal-browser";
import { loginRequest } from "../../../msalConfig";       // adjust path if needed
// import { fetchImageAsBase64 } from "../../services/api";

/* ------------------------------------------------------------------ */
/*                              Component                             */
/* ------------------------------------------------------------------ */
const VulnerabilityOverview = () => {
  /* â”€â”€â”€â”€â”€â”€â”€â”€  Chart + chat local state  â”€â”€â”€â”€â”€â”€â”€â”€ */
  const [graphData, setGraphData]   = useState({});
  const [graph2Data, setGraph2Data] = useState({});
  const [graph3Data, setGraph3Data] = useState({});
  const [graph4Data, setGraph4Data] = useState({});
  const [chatHistory, setChatHistory] = useState([]);
  const [userInput, setUserInput]     = useState("");

  /* â”€â”€â”€â”€â”€â”€â”€â”€  MSAL / Auth state  â”€â”€â”€â”€â”€â”€â”€â”€ */
  const { instance, accounts, inProgress } = useMsal();
  const [redirectDone, setRedirectDone]   = useState(false);
  const [accessGranted, setAccessGranted] = useState(null);        // null = still checking
  const [accessToken, setAccessToken] = useState(null);
  const [base64Images, setBase64Images] = useState([]);
  const [isTyping, setIsTyping] = useState(false);
  const [expandedRow, setExpandedRow] = useState(null);
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [fetchedRows, setFetchedRows] = useState([]);
  const [expandedIncident, setExpandedIncident] = useState(null);
  const [openConfirmDialog, setOpenConfirmDialog] = useState(false);
  const [selectedFile, setSelectedFile] = useState(null);
  const [selectedIncident, setSelectedIncident] = useState(null);
  const [data, setData] = useState([]);
  const [selectedYear, setSelectedYear] = useState("2023");
  const [selectedYearRCA, setSelectedYearRCA] = useState("2023");
  const [columnFilters, setColumnFilters] = useState({
    Reported_Date_Time: [],
    Category: "",
    Source: "",
    Incident_Number: ""
  });
  const [categoryFilter, setCategoryFilter] = useState("");    // default: "All" (empty is all)
  const [categoryAnchorEl, setCategoryAnchorEl] = useState(null);
  const [sourceAnchorEl, setSourceAnchorEl] = useState(null);
  const [incidentNumberAnchorEl, setIncidentNumberAnchorEl] = useState(null);
  const [dynamicCategories, setDynamicCategories] = useState([]);
  const [reportedDateAnchorEl, setReportedDateAnchorEl] = useState(null);
  const [dynamicReportedDates, setDynamicReportedDates] = useState([]);
  const [selectedYearAvgTime, setSelectedYearAvgTime] = useState("2023");
  const [dateFilterHierarchy, setDateFilterHierarchy] = useState({});
  const [expandedFilterItems, setExpandedFilterItems] = useState({});

  // const requiredGroupId = "a413e120-33ad-4634-b863-9c38689b1462";  // <-- your AD group
  const requiredGroupId = "04d6d1b8-fe98-42ba-aa33-dfa1e04eaa60";    //Dev AD Group

  const incidentDetailKeys = {
    Impacted_Site_Service: "Impacted Site/Service",
    Permanent_Fix: "Permanent Fix",
    Problem_Record: "Problem Record",
    // Problem_Statement: "Problem Statement",
    Incident_Description: "Incident Description",
    RCA_Analysis: "RCA Analysis",
    Root_Cause: "Root Cause",
    LocationImpacted: "Location Impacted",
    subcategory: "Subcategory",
    knowledgeArticle: "Knowledge Article",
    fileName: "Filename",
    Resolved_Date_Time: "Resolved Date Time",
    rcaLink: "RCA Link",
    ActionPlan: "Action Plan",
  };

  /* ------------------------------------------------------------------ */
  /* 1ï¸âƒ£  Handle MSAL redirect once                                    */
  /* ------------------------------------------------------------------ */
  useEffect(() => {
    instance
      .handleRedirectPromise()
      .catch((err) => console.error("Redirect handling error:", err))
      .finally(() => setRedirectDone(true));
  }, [instance]);

  /* ------------------------------------------------------------------ */
  /* 2ï¸âƒ£  Trigger login if nobody signedâ€‘in                             */
  /* ------------------------------------------------------------------ */
  useEffect(() => {
    if (!redirectDone || inProgress !== InteractionStatus.None) return;

    if (accounts.length === 0) {
      instance.loginRedirect(loginRequest);
    }
  }, [redirectDone, inProgress, accounts, instance]);

  /* ------------------------------------------------------------------ */
  /* 3ï¸âƒ£  After login, check group membership                           */
  /* ------------------------------------------------------------------ */
  useEffect(() => {
    if (!redirectDone || inProgress !== InteractionStatus.None) return;
    if (accounts.length === 0) return;                    // not logged in yet

    const checkGroup = async () => {
      try {
        const tokenResp = await instance.acquireTokenSilent({
          ...loginRequest,
          account: accounts[0],
        });
        if (!accessToken) {
              setAccessToken(tokenResp.idToken || tokenResp.accessToken);
              }
        const graphRes = await fetch(
          "https://graph.microsoft.com/v1.0/me/memberOf?$select=id",
          { headers: { Authorization: `Bearer ${tokenResp.accessToken}` } }
        );
        const data = await graphRes.json();
        const allowed = (data.value || []).some((g) => g.id === requiredGroupId);
        setAccessGranted(allowed);
      } catch (err) {
        console.error("Group check failed:", err);
        setAccessGranted(false);
      }
    };

    checkGroup();
  }, [redirectDone, inProgress, accounts, instance]);

  // useEffect(() => {
  //   if (!redirectDone || inProgress !== InteractionStatus.None) return;
  //   if (accounts.length === 0) {
  //     console.warn("âš ï¸ No MSAL account found. Assuming Edge Lambda already authenticated the user.");
  //     return;
  //   }

  //   const checkGroup = async () => {
  //     try {
  //       const account = accounts[0];
  //       const tokenResp = await instance.acquireTokenSilent({
  //         ...loginRequest,
  //         account,
  //       });

  //       if (!accessToken) {
  //         setAccessToken(tokenResp.idToken || tokenResp.accessToken);
  //       }

  //       const graphRes = await fetch(
  //         "https://graph.microsoft.com/v1.0/me/memberOf?$select=id",
  //         { headers: { Authorization: `Bearer ${tokenResp.accessToken}` } }
  //       );

  //       const data = await graphRes.json();
  //       const allowed = (data.value || []).some((g) => g.id === requiredGroupId);
  //       setAccessGranted(allowed);
  //     } catch (err) {
  //       console.error("Group check failed:", err);
  //       setAccessGranted(false);
  //     }
  //   };

  //   checkGroup();
  // }, [redirectDone, inProgress, accounts, instance]);

  /* ------------------------------------------------------------------ */
  /* 4ï¸âƒ£  Open WebSocket only after access is granted                    */
  /* ------------------------------------------------------------------ */
  // useEffect(() => {
  //   if (!accessGranted || !accessToken) return;                            // either null or false
  //   connectWebSocket(accessToken);
  //   listenForFetch(
  //     null,
  //     (g1) => setGraphData(g1 || {}),
  //     (g2) => setGraph2Data(g2 || {})
  //   );
  // }, [accessGranted,accessToken]);

  /* ------------------------------------------------------------------ */
  /*                            Early returns                           */
  /* ------------------------------------------------------------------ */
  // if (!redirectDone || inProgress !== InteractionStatus.None) {
  //   return <p>Loading / redirectingâ€¦</p>;
  // }
  // if (accessGranted === null) {
  //   return <p>Verifying accessâ€¦</p>;
  // }
  // if (!accessGranted) {
  //   return <p>No access. Contact admin.</p>;
  // }

  /* ------------------------------------------------------------------ */
  /*                     Charts + chat: identical logic                 */
  /* ------------------------------------------------------------------ */
useEffect(() => {
  const hierarchy = {};
  fetchedRows.forEach(row => {
    if (row.Reported_Date_Time) {
      const date = new Date(row.Reported_Date_Time);
      const year = date.getFullYear().toString();
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const day = date.toISOString().split('T')[0];

      if (!hierarchy[year]) {
        hierarchy[year] = {};
      }
      if (!hierarchy[year][month]) {
        hierarchy[year][month] = [];
      }
      if (!hierarchy[year][month].includes(day)) {
        hierarchy[year][month].push(day);
      }
    }
  });
  setDateFilterHierarchy(hierarchy);
}, [fetchedRows]);



const months = [
  "January", "February", "March", "April", "May", "June",
  "July", "August", "September", "October", "November", "December",
];

const getLineChartOptions = (selectedYear) => {
  // Clear any previous series by always creating series new from scratch
  const yearData = graphData[selectedYear] || {};

  // Only add categories found in months of the selected year
  const allCategoriesSet = new Set();
  months.forEach((month) => {
    const monthData = yearData[month] || {};
    Object.keys(monthData).forEach((cat) => allCategoriesSet.add(cat));
  });
  const allCategories = Array.from(allCategoriesSet);

  // Only include series that have at least one non-zero value for the year
  const series = allCategories.map((category) => {
    const seriesData = months.map((month) => {
      const monthData = yearData[month] || {};
      return monthData[category] || 0;
    });
    // Only include if there is real data
    if (seriesData.some(v => v !== 0)) {
      return {
        name: `${selectedYear} - ${category}`,
        type: "bar",
        stack: selectedYear,
        barGap: 0.2,
        emphasis: { focus: "series" },
        data: seriesData,
      };
    }
    return null;
  }).filter(Boolean);

  return {
    title: {
      text: `Monthly Incident Trend - ${selectedYear}`,
      left: "center",
      textStyle: {
        fontSize: 16,
        fontWeight: 600,
      },
    },
    tooltip: {
      trigger: 'item',
      formatter: function(params) {
        if (params.value === 0) return '';
        return `<strong>${params.seriesName}</strong><br/>
                Month: ${params.name}<br/>
                Count: <span style="font-weight:bold;color:${params.color}">${params.value}</span>`;
      }
    },
    legend: {
      show: false, // Hide legends unless needed
    },
    xAxis: {
      type: "category",
      data: months,
      axisLabel: {
        rotate: 45,
      },
    },
    yAxis: {
      type: "value",
      name: "Incident Count",
    },
    grid: {
      left: "4%",
      right: "4%",
      bottom: "10%",
      containLabel: true,
    },
    series,
  };
};



 const getAvgTimeBarChartOptions = (year) => {
  const monthData = graph2Data?.[year] || {};
  const data = months.map((m) => monthData[m] ?? 0);

  return {
    title: {
      text: `Monthly Avg Time Taken - ${year}`,
      left: "center",
      textStyle: { fontSize: 16, fontWeight: 600 },
    },
    tooltip: { trigger: "axis" },
    xAxis: {
      type: "category",
      data: months,
      axisLabel: { rotate: 45 },
    },
    yAxis: {
      type: "value",
      name: "Avg Time",
      min: 0,
    },
    color: ['#5470C6'],
    series: [
      {
        name: `Avg Time - ${year}`,
        type: "bar",
        data,
        emphasis: { focus: "series" },
      },
    ],
    grid: {
      left: "4%",
      right: "4%",
      bottom: "10%",
      containLabel: true,
    },
  };
};


const getRcaBarChartOptions = (graph3Data) => {
  const years = ["2023", "2024", "2025"];
  
  // Calculate total RCA count for each year
  const series = years.map(year => {
    const yearData = graph3Data?.[year] || {};
    
    // Sum all monthly values for this year
    const yearlyTotal = Object.values(yearData).reduce((sum, count) => sum + (count || 0), 0);
    
    return yearlyTotal;
  });

  return {
    title: {
      text: "RCA Count by Year",
      left: "center",
      textStyle: {
        fontSize: 16,
        fontWeight: 600,
      }
    },
    tooltip: {
      trigger: "axis",
      axisPointer: {
        type: "shadow"
      },
      formatter: function(params) {
        const year = params[0].name;
        const count = params[0].value;
        return `${year}<br/>RCA Count: ${count}`;
      }
    },
    xAxis: {
      type: "category",
      data: years,
      axisLabel: {
        fontSize: 12
      }
    },
    yAxis: {
      type: "value",
      name: "RCA Count",
      min: 0
    },
    series: [
      {
        name: "RCA Count",
        type: "bar",
        data: series,
        itemStyle: {
          color: "#5470C6"
        },
        barWidth: "30%",
        emphasis: {
          focus: "series"
        }
      }
    ],
    grid: {
      left: "3%",
      right: "4%",
      bottom: "8%",
      containLabel: true
    },
    color: ['#645394', '#A77DD1', '#83C5BE', '#B8E0D2']
  };
};

const getRcaPriorityPieChartOptions = (graph4Data, selectedYear) => {
  const yearData = graph4Data?.[selectedYear];

  if (!yearData) return {};

  const data = Object.entries(yearData).map(([priority, count]) => ({
    name: priority,
    value: count
  }));

  return {
    title: {
      text: `RCA Distribution by Priority - ${selectedYear}`,
      left: "center"
    },
    tooltip: {
      trigger: "item"
    },
    legend: {
      orient: "vertical",
      left: "left"
    },
    series: [
      {
        name: "Priority",
        type: "pie",
        radius: "50%",
        data,
        emphasis: {
          itemStyle: {
            shadowBlur: 10,
            shadowOffsetX: 0,
            shadowColor: "rgba(0, 0, 0, 0.5)"
          }
        },
        label: {
          formatter: "{b}: {c} ({d}%)"
        }
      }
    ]
  };
};



useEffect(() => {
  if (!accessToken) return;
  const ws = connectWebSocket(accessToken);

  // 1. Register listeners
  listenForFetch(
    (incidents) => {
      setFetchedRows((prev) => {
        const combined = [...prev, ...incidents];

        const uniqueMap = new Map();
        combined.forEach((item) => {
          uniqueMap.set(item.Incident_Number, item);
        });

        return Array.from(uniqueMap.values());
      });
    },
    //  (g1) => setGraphData(g1 || {}),
    (g1) => {
  console.log("ðŸ“Š Graph1 raw data received:", g1);
  setGraphData(g1 || {});
},
     (g2) => setGraph2Data(g2 || {}),
     (g3) => setGraph3Data(g3 || {}),
     (g4) => setGraph4Data(g4 || {})
  );

  // 2. Send fetch after listeners are registered
  // sendFetchRequest();

}, [accessToken]);


const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };


// useEffect(() => {
//   console.log("ðŸ“¦ fetchedRows updated:", fetchedRows);
// }, [fetchedRows]);

// useEffect(() => {
//   listenForFetch(setFetchedRows);
// }, []);

const handleToggle = (incidentNumber) => {
  setExpandedIncident(prev =>
    prev === incidentNumber ? null : incidentNumber
  );
};

// const handleDelete = (file, incidentNumber) => {
//   sendDeleteRequest(file, incidentNumber);
// };

const handleDeleteClick = (file, incidentNumber) => {
  setSelectedFile(file);
  setSelectedIncident(incidentNumber);
  setOpenConfirmDialog(true); // show dialog
};

const handleConfirmDelete = () => {
  sendDeleteRequest( selectedIncident);
  setOpenConfirmDialog(false); // close dialog
};

const handleCancelDelete = () => {
  setSelectedFile(null);
  setSelectedIncident(null);
  setOpenConfirmDialog(false); // just close
};

const filteredRows = fetchedRows.filter((row) => {
  const rowDate = row.Reported_Date_Time ? new Date(row.Reported_Date_Time).toISOString().split("T")[0] : null;
  const categoryMatch = columnFilters.Category === "" || row.Category === columnFilters.Category;
  const dateMatch = columnFilters.Reported_Date_Time.length === 0 || (rowDate && columnFilters.Reported_Date_Time.includes(rowDate));
  const sourceMatch = columnFilters.Source === "" || row.Source === columnFilters.Source;
  const incidentNumberMatch = row.Incident_Number.toLowerCase().includes(columnFilters.Incident_Number.toLowerCase());
  return categoryMatch && dateMatch && sourceMatch && incidentNumberMatch;
});


// const pagedRows = filteredRows.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage);

  useEffect(() => {
    const uniqueCategories = [...new Set(fetchedRows.map(row => row.Category).filter(Boolean))];
    setDynamicCategories(uniqueCategories.sort());
  }, [fetchedRows]);

  const handleFilterExpand = (key) => {
    setExpandedFilterItems(prev => ({ ...prev, [key]: !prev[key] }));
  };

  const handleDateSelect = (items, shouldSelect) => {
    const currentSelection = new Set(columnFilters.Reported_Date_Time);
    items.forEach(item => {
      if (shouldSelect) {
        currentSelection.add(item);
      } else {
        currentSelection.delete(item);
      }
    });
    setColumnFilters(prev => ({ ...prev, Reported_Date_Time: Array.from(currentSelection) }));
  };

  const getSelectionState = (items) => {
    const selectedCount = items.filter(item => columnFilters.Reported_Date_Time.includes(item)).length;
    if (selectedCount === 0) return { checked: false, indeterminate: false };
    if (selectedCount === items.length) return { checked: true, indeterminate: false };
    return { checked: false, indeterminate: true };
  };

  if (inProgress !== InteractionStatus.None) return <p>Loadingâ€¦</p>;
  if (accessGranted === null) return <p>Verifying accessâ€¦</p>;
  if (!accessGranted) return <p>No access. Contact admin.</p>;
  /* ------------------------------------------------------------------ */
  /*                               UI                                   */
  /* ------------------------------------------------------------------ */
  return (
    <div style={{ padding: 5, fontFamily: "Segoe UI, sans-serif" }}>
      <h2>Incident Overview</h2>
      <div style={{ display: "flex", flexWrap: "wrap", gap: 20}}>
        <div style={cardStyle}>
            {/* Chart Title - Already rendered inside ECharts config */}
            <ReactEcharts
              key={selectedYear} // Forces remount on year change
              option={getLineChartOptions(selectedYear)}
              style={{ height: 300 }}
            />

            {/* Move year buttons below the chart title, inside the same card */}
            <div style={{ textAlign: "center", marginTop: 10 }}>
              {["2023", "2024", "2025"].map((year) => (
                <button
                  key={year}
                  onClick={() => setSelectedYear(year)}
                  style={{
                    margin: "0 8px",
                    padding: "6px 12px",
                    fontWeight: selectedYear === year ? 'bold' : 'normal',
                    borderRadius: "6px",
                    border: selectedYear === year ? "2px solid #645394" : "1px solid #ccc",
                    backgroundColor: selectedYear === year ? "#eee8ff" : "#fff",
                    cursor: "pointer"
                  }}
                >
                  {year}
                </button>
              ))}
            </div>
          </div>
       <div style={cardStyle}>
            <ReactEcharts
              key={selectedYearAvgTime}
              option={getAvgTimeBarChartOptions(selectedYearAvgTime)}
              style={{ height: 300 }}
            />
            <div style={{ textAlign: "center", marginTop: 10 }}>
              {["2023", "2024", "2025"].map((year) => (
                <button
                  key={year}
                  onClick={() => setSelectedYearAvgTime(year)}
                  style={{
                    margin: "0 8px",
                    padding: "6px 12px",
                    fontWeight: selectedYearAvgTime === year ? 'bold' : 'normal',
                    borderRadius: "6px",
                    border: selectedYearAvgTime === year ? "2px solid #645394" : "1px solid #ccc",
                    backgroundColor: selectedYearAvgTime === year ? "#eee8ff" : "#fff",
                    cursor: "pointer"
                  }}
                >
                  {year}
                </button>
              ))}
            </div>
          </div>
        <div style={cardStyle}>
    {/* âœ… Fixed: Pass required parameters */}
    <ReactEcharts option={getRcaBarChartOptions(graph3Data, selectedYear)} style={{ height: 300 }} />
  </div>
  
  <div style={cardStyle}>
    {/* âœ… Fixed: Pass required parameters */}
    <ReactEcharts option={getRcaPriorityPieChartOptions(graph4Data, selectedYearRCA)} style={{ height: 300 }} />
     <div style={{ textAlign: "center", marginTop: 10 }}>
      <span style={{ fontSize: "12px", marginRight: "10px" }}>Priority for:</span>
      {["2023", "2024", "2025"].map((year) => (
        <button
          key={year}
          onClick={() => setSelectedYearRCA(year)}
          style={{
            margin: "0 4px",
            padding: "4px 8px",
            fontSize: "12px",
            fontWeight: selectedYearRCA === year ? 'bold' : 'normal',
            borderRadius: "4px",
            border: selectedYearRCA === year ? "2px solid #645394" : "1px solid #ccc",
            backgroundColor: selectedYearRCA === year ? "#eee8ff" : "#fff",
            cursor: "pointer"
          }}
        >
          {year}
        </button>
      ))}
    </div>
  </div>
      </div>

      {/* TABLE */}
      <Box>
              <TableContainer component={Paper} sx={{ mt: 3 }}>
                <Table>
                 <TableHead>
                    <TableRow sx={{ backgroundColor: "#212A55" }}>
                      <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          Incident Number
                          <IconButton
                            size="small"
                            onClick={(e) => setIncidentNumberAnchorEl(e.currentTarget)}
                            sx={{ ml: 1, color: "white" }}
                          >
                            <FilterListIcon fontSize="small" />
                          </IconButton>
                        </Box>
                        <Menu
                          anchorEl={incidentNumberAnchorEl}
                          open={Boolean(incidentNumberAnchorEl)}
                          onClose={() => setIncidentNumberAnchorEl(null)}
                        >
                          <Box sx={{ p: 2 }}>
                            <TextField
                              variant="outlined"
                              size="small"
                              placeholder="Search..."
                              value={columnFilters.Incident_Number}
                              onChange={(e) => setColumnFilters(prev => ({ ...prev, Incident_Number: e.target.value }))}
                              onClick={(e) => e.stopPropagation()} // Prevent menu from closing
                            />
                          </Box>
                        </Menu>
                      </TableCell>

                      {/* Reported Date Time: Filter Menu */}
                    <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        Reported Date Time
                        <IconButton
                          size="small"
                          onClick={(e) => setReportedDateAnchorEl(e.currentTarget)}
                          sx={{ ml: 1, color: "white" }}
                        >
                          <FilterListIcon fontSize="small" />
                        </IconButton>
                      </Box>
                      <Menu
                        anchorEl={reportedDateAnchorEl}
                        open={Boolean(reportedDateAnchorEl)}
                        onClose={() => setReportedDateAnchorEl(null)}
                        PaperProps={{ style: { maxHeight: 400, width: '30ch' } }}
                      >
                        <MenuItem onClick={() => handleDateSelect(Object.values(dateFilterHierarchy).flatMap(y => Object.values(y).flat()), false)}>
                          <ListItemText primary="Clear All" />
                        </MenuItem>
                        {Object.entries(dateFilterHierarchy).sort((a, b) => b[0].localeCompare(a[0])).map(([year, months]) => {
                          const yearDates = Object.values(months).flat();
                          const { checked: yearChecked, indeterminate: yearIndeterminate } = getSelectionState(yearDates);
                          return (
                            <div key={year}>
                              <MenuItem>
                                <IconButton size="small" onClick={() => handleFilterExpand(year)}>
                                  {expandedFilterItems[year] ? <KeyboardArrowDownIcon /> : <KeyboardArrowRightIcon />}
                                </IconButton>
                                <Checkbox
                                  checked={yearChecked}
                                  indeterminate={yearIndeterminate}
                                  onClick={() => handleDateSelect(yearDates, !yearChecked)}
                                />
                                <ListItemText primary={year} />
                              </MenuItem>
                              <Collapse in={expandedFilterItems[year]} timeout="auto" unmountOnExit>
                                <Box sx={{ pl: 4 }}>
                                  {Object.entries(months).sort((a, b) => a[0].localeCompare(b[0])).map(([month, days]) => {
                                    const monthDates = days;
                                    const { checked: monthChecked, indeterminate: monthIndeterminate } = getSelectionState(monthDates);
                                    const monthName = new Date(year, month - 1).toLocaleString('default', { month: 'long' });
                                    return (
                                      <div key={month}>
                                        <MenuItem>
                                          <IconButton size="small" onClick={() => handleFilterExpand(`${year}-${month}`)}>
                                            {expandedFilterItems[`${year}-${month}`] ? <KeyboardArrowDownIcon /> : <KeyboardArrowRightIcon />}
                                          </IconButton>
                                          <Checkbox
                                            checked={monthChecked}
                                            indeterminate={monthIndeterminate}
                                            onClick={() => handleDateSelect(monthDates, !monthChecked)}
                                          />
                                          <ListItemText primary={monthName} />
                                        </MenuItem>
                                        <Collapse in={expandedFilterItems[`${year}-${month}`]} timeout="auto" unmountOnExit>
                                          <Box sx={{ pl: 4 }}>
                                            {days.sort((a, b) => a.localeCompare(b)).map(day => {
                                              const { checked: dayChecked } = getSelectionState([day]);
                                              return (
                                                <MenuItem key={day} onClick={() => handleDateSelect([day], !dayChecked)}>
                                                  <Checkbox checked={dayChecked} />
                                                  <ListItemText primary={day} />
                                                </MenuItem>
                                              );
                                            })}
                                          </Box>
                                        </Collapse>
                                      </div>
                                    );
                                  })}
                                </Box>
                              </Collapse>
                            </div>
                          );
                        })}
                      </Menu>
                  </TableCell>


                <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>Problem Statement</TableCell>
                <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>Time Taken to Resolve</TableCell>

                {/* Category: Filter Menu */}
                <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    Category
                    <IconButton
                      size="small"
                      onClick={(e) => setCategoryAnchorEl(e.currentTarget)}
                      sx={{ ml: 1, color: "white" }}
                    >
                      <FilterListIcon fontSize="small" />
                    </IconButton>
                  </Box>
                  <Menu
                    anchorEl={categoryAnchorEl}
                    open={Boolean(categoryAnchorEl)}
                    onClose={() => setCategoryAnchorEl(null)}
                  >
                    <MenuItem
                      onClick={() => {
                        setColumnFilters((prev) => ({ ...prev, Category: "" }));
                        setCategoryAnchorEl(null);
                      }}
                      selected={columnFilters.Category === ""}
                    >
                      <Checkbox checked={columnFilters.Category === ""} />
                      <ListItemText primary="All" />
                    </MenuItem>
                    {dynamicCategories.map((cat) => (
                      <MenuItem
                        key={cat}
                        selected={columnFilters.Category === cat}
                        onClick={() => {
                          setColumnFilters((prev) => ({ ...prev, Category: cat }));
                          setCategoryAnchorEl(null);
                        }}
                      >
                        <Checkbox checked={columnFilters.Category === cat} />
                        <ListItemText primary={cat} />
                      </MenuItem>
                    ))}
                  </Menu>
                </TableCell>
                <TableCell sx={{ color: "white", whiteSpace: "nowrap" }}>
                  <Box sx={{ display: 'flex', alignItems: 'center' }}>
                    Source
                    <IconButton
                      size="small"
                      onClick={(e) => setSourceAnchorEl(e.currentTarget)}
                      sx={{ ml: 1, color: "white" }}
                    >
                      <FilterListIcon fontSize="small" />
                    </IconButton>
                  </Box>
                  <Menu
                    anchorEl={sourceAnchorEl}
                    open={Boolean(sourceAnchorEl)}
                    onClose={() => setSourceAnchorEl(null)}
                  >
                    <MenuItem
                      onClick={() => {
                        setColumnFilters((prev) => ({ ...prev, Source: "" }));
                        setSourceAnchorEl(null);
                      }}
                      selected={columnFilters.Source === ""}
                    >
                      <Checkbox checked={columnFilters.Source === ""} />
                      <ListItemText primary="All" />
                    </MenuItem>
                    <MenuItem
                      onClick={() => {
                        setColumnFilters((prev) => ({ ...prev, Source: "MDB" }));
                        setSourceAnchorEl(null);
                      }}
                      selected={columnFilters.Source === "MDB"}
                    >
                      <Checkbox checked={columnFilters.Source === "MDB"} />
                      <ListItemText primary="MDB" />
                    </MenuItem>
                    <MenuItem
                      onClick={() => {
                        setColumnFilters((prev) => ({ ...prev, Source: "RCA" }));
                        setSourceAnchorEl(null);
                      }}
                      selected={columnFilters.Source === "RCA"}
                    >
                      <Checkbox checked={columnFilters.Source === "RCA"} />
                      <ListItemText primary="RCA" />
                    </MenuItem>
                  </Menu>
                </TableCell>
                <TableCell sx={{ color: "white" }}></TableCell>
            </TableRow>
          </TableHead>

          <TableBody>
            {(filteredRows || []).slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage).map((row) => (
              <React.Fragment key={fetchedRows.id}>
                <TableRow hover>
                  <TableCell>
                    <Typography
                      sx={{ cursor: "pointer", color: "blue", textDecoration: "underline" }}
                      // onClick={() => setExpandedRow(expandedRow === row.id ? null : row.id)}
                      onClick={() => handleToggle(row.Incident_Number)} style={{ cursor: 'pointer' }}
                    >
                      {row.Incident_Number}
                    </Typography>
                  </TableCell>
                  <TableCell>{new Date(row.Reported_Date_Time).toISOString().split("T")[0]}</TableCell>
                  <TableCell>
                    <Typography
                      title={row.Problem_Statement}
                      sx={{
                        whiteSpace: 'nowrap',
                        overflow: 'hidden',
                        textOverflow: 'ellipsis',
                        maxWidth: 200, // You can adjust this width based on layout
                        cursor: 'pointer',
                      }}
                    >
                      {row.Problem_Statement}
                    </Typography>
                  </TableCell>

                  <TableCell>{row.Time_Taken_to_Resolve}</TableCell>
                  <TableCell>{row.Category}</TableCell>
                  <TableCell>{row.Source}</TableCell>
                  <TableCell>        
                  {console.log("ðŸ”Ž row:", row)}
                  <IconButton
                    color="error"
                    // onClick={() => handleDelete(row.file, row.Incident_Number)}
                    onClick={() => handleDeleteClick({ name: row.fileName }, row.Incident_Number)}
                  >
                    <DeleteIcon />
                  </IconButton>
                </TableCell>
                </TableRow>
                <Dialog
            open={openConfirmDialog}
            onClose={handleCancelDelete}
            BackdropProps={{
        style: {
          backgroundColor: 'rgba(0, 0, 0, 0.2)',  // semi-transparent black
          backdropFilter: 'blur(2px)'             // optional blur for a frosted-glass effect
        }
      }}
          >
            <Box p={3}>
              <Typography variant="h6">Are you sure you want to delete this record?</Typography>
              <Box mt={2} display="flex" justifyContent="flex-end">
                <button onClick={handleCancelDelete} style={{ marginRight: "10px" }}>
                  No
                </button>
                <button onClick={handleConfirmDelete} style={{ backgroundColor: "red", color: "white" }}>
                  Yes
                </button>
              </Box>
            </Box>
          </Dialog>
          
                {expandedIncident === row.Incident_Number && (
                  <TableRow>
                    <TableCell colSpan={7}>
                      <Collapse in={true} timeout="auto" unmountOnExit>
                        <Paper elevation={3} sx={{ p: 2, mt: 1 }}>
                          <Typography variant="h6" gutterBottom>Incident Details</Typography>
                          {Object.entries(incidentDetailKeys).map(([key, label]) => {
                            const value = row[key];
                            if (!value) return null;

                            if (key === "rcaLink") {
                              return (
                                <Typography key={key}>
                                  <strong>{label}:</strong> <a href={`https://${value}`} target="_blank" rel="noopener noreferrer">{value}</a>
                                </Typography>
                              );
                            }

                            if (key === "ActionPlan" && Array.isArray(value) && value.length > 0) {
                              const headers = Object.keys(value[0]);
                              return (
                                <Box key={key} sx={{ mt: 2 }}>
                                  <Typography variant="subtitle1" gutterBottom><strong>{label}</strong></Typography>
                                  <TableContainer component={Paper}>
                                    <Table size="small" aria-label="action plan table">
                                      <TableHead>
                                        <TableRow>
                                          {headers.map(header => <TableCell key={header} sx={{ textTransform: 'capitalize' }}><strong>{header.replace(/_/g, ' ')}</strong></TableCell>)}
                                        </TableRow>
                                      </TableHead>
                                      <TableBody>
                                        {value.map((plan, index) => (
                                          <TableRow key={index}>
                                            {headers.map(header => <TableCell key={header}>{plan[header]}</TableCell>)}
                                          </TableRow>
                                        ))}
                                      </TableBody>
                                    </Table>
                                  </TableContainer>
                                </Box>
                              );
                            }

                            if (key !== "ActionPlan") {
                              return (
                                <Typography key={key}>
                                  <strong>{label}:</strong> {value}
                                </Typography>
                              );
                            }
                            
                            return null;
                          })}
                        </Paper>
                      </Collapse>
                    </TableCell>
                  </TableRow>
                )}
              </React.Fragment>
            ))}
          </TableBody>
                </Table>
                <TablePagination
                  component="div"
                  count={filteredRows.length}
                  page={page}
                  onPageChange={handleChangePage}
                  rowsPerPage={rowsPerPage}
                  onRowsPerPageChange={handleChangeRowsPerPage}
                  rowsPerPageOptions={[1, 5, 10, 50]}
                />
              </TableContainer>
            </Box>
    </div>
  );
};

/* ------------------------------------------------------------------ */
/*                            Tiny styles                             */
/* ------------------------------------------------------------------ */
const cardStyle = {
  flex: "1 1 calc(50% - 10px)",
  boxSizing: "border-box",
  background: "#fff",
  borderRadius: 12,
  boxShadow: "0 4px 10px rgba(0,0,0,0.1)",
  padding: 15,
  minWidth: "350px",
};

export default VulnerabilityOverview;